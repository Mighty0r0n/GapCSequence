
// A dynamic programming evaluator generated by GAP-C.
//
//   GAP-C version:
//     2021.05.18
//
//   GAP-C call:
//     gapc -i global alignment.gap --tab A --tab D
//
//


#define GAPC_MOD_TRANSLATION_UNIT
#include "out.hh"

#include "rtlib/subopt.hh"

#include "rtlib/generic_opts.hh"
#include "rtlib/pareto_dom_sort.hh"
#include "rtlib/pareto_yukish_ref.hh"

int &  out::nt_A(unsigned int t_0_i, unsigned int t_1_i) {
  if (A_table.is_tabulated(t_0_i, t_1_i)) {
    return A_table.get(t_0_i, t_1_i);
  }
  int answers;
  empty(answers);
  empty(answers);
  int ret_0;
  if ((((t_0_right_most - t_0_i) >= 1) && ((t_1_right_most - t_1_i) >= 0))) {
    int ret_4 = nt_I((t_0_i + 1), t_1_i);
    int a_1 = ret_4;
    if (is_not_empty(a_1)) {
      char ret_2 = CHAR(t_0_seq, t_0_i, (t_0_i + 1));
      char ret_1_0 = ret_2;
      bool ret_3 = EMPTY(t_1_seq, t_1_i, t_1_i);
      bool ret_1_1 = ret_3;
      char a_0_0 = ret_1_0;
      bool a_0_1 = ret_1_1;
      if ((is_not_empty(a_0_0) && is_not_empty(a_0_1))) {
        ret_0 = Ins(a_0_0, a_0_1, a_1);
      } else {
        empty(ret_0);
      }
      erase(a_0_0);
      erase(a_0_1);
    } else {
      empty(ret_0);
    }
    erase(a_1);
  } else {
    empty(ret_0);
  }
  if (is_not_empty(ret_0)) {
    push_back_max(answers, ret_0);
  }
  int ret_5;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_1_right_most - t_1_i) >= 1))) {
    int ret_9 = nt_D(t_0_i, (t_1_i + 1));
    int a_3 = ret_9;
    if (is_not_empty(a_3)) {
      bool ret_7 = EMPTY(t_0_seq, t_0_i, t_0_i);
      bool ret_6_0 = ret_7;
      char ret_8 = CHAR(t_1_seq, t_1_i, (t_1_i + 1));
      char ret_6_1 = ret_8;
      bool a_2_0 = ret_6_0;
      char a_2_1 = ret_6_1;
      if ((is_not_empty(a_2_0) && is_not_empty(a_2_1))) {
        ret_5 = Del(a_2_0, a_2_1, a_3);
      } else {
        empty(ret_5);
      }
      erase(a_2_0);
      erase(a_2_1);
    } else {
      empty(ret_5);
    }
    erase(a_3);
  } else {
    empty(ret_5);
  }
  if (is_not_empty(ret_5)) {
    push_back_max(answers, ret_5);
  }
  int ret_10 = nt_R(t_0_i, t_1_i);
  if (is_not_empty(ret_10)) {
    push_back_max(answers, ret_10);
  }
  int eval = h(answers);
  erase(answers);
  A_table.set(t_0_i, t_1_i, eval);
  return A_table.get(t_0_i, t_1_i);
}

int &  out::nt_D(unsigned int t_0_i, unsigned int t_1_i) {
  if (D_table.is_tabulated(t_0_i, t_1_i)) {
    return D_table.get(t_0_i, t_1_i);
  }
  int answers;
  empty(answers);
  empty(answers);
  int ret_0;
  if ((((t_0_right_most - t_0_i) >= 1) && ((t_1_right_most - t_1_i) >= 0))) {
    int ret_4 = nt_I((t_0_i + 1), t_1_i);
    int a_1 = ret_4;
    if (is_not_empty(a_1)) {
      char ret_2 = CHAR(t_0_seq, t_0_i, (t_0_i + 1));
      char ret_1_0 = ret_2;
      bool ret_3 = EMPTY(t_1_seq, t_1_i, t_1_i);
      bool ret_1_1 = ret_3;
      char a_0_0 = ret_1_0;
      bool a_0_1 = ret_1_1;
      if ((is_not_empty(a_0_0) && is_not_empty(a_0_1))) {
        ret_0 = Ins(a_0_0, a_0_1, a_1);
      } else {
        empty(ret_0);
      }
      erase(a_0_0);
      erase(a_0_1);
    } else {
      empty(ret_0);
    }
    erase(a_1);
  } else {
    empty(ret_0);
  }
  if (is_not_empty(ret_0)) {
    push_back_max(answers, ret_0);
  }
  int ret_5;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_1_right_most - t_1_i) >= 1))) {
    int ret_9 = nt_D(t_0_i, (t_1_i + 1));
    int a_3 = ret_9;
    if (is_not_empty(a_3)) {
      bool ret_7 = EMPTY(t_0_seq, t_0_i, t_0_i);
      bool ret_6_0 = ret_7;
      char ret_8 = CHAR(t_1_seq, t_1_i, (t_1_i + 1));
      char ret_6_1 = ret_8;
      bool a_2_0 = ret_6_0;
      char a_2_1 = ret_6_1;
      if ((is_not_empty(a_2_0) && is_not_empty(a_2_1))) {
        ret_5 = Del(a_2_0, a_2_1, a_3);
      } else {
        empty(ret_5);
      }
      erase(a_2_0);
      erase(a_2_1);
    } else {
      empty(ret_5);
    }
    erase(a_3);
  } else {
    empty(ret_5);
  }
  if (is_not_empty(ret_5)) {
    push_back_max(answers, ret_5);
  }
  int ret_10 = nt_R(t_0_i, t_1_i);
  if (is_not_empty(ret_10)) {
    push_back_max(answers, ret_10);
  }
  int eval = h(answers);
  erase(answers);
  D_table.set(t_0_i, t_1_i, eval);
  return D_table.get(t_0_i, t_1_i);
}

int out::nt_Foo() {
  int answers;
  empty(answers);
  int ret_0 = nt_A(t_0_left_most, t_1_left_most);
  answers = ret_0;
  return answers;
}

int out::nt_I(unsigned int t_0_i, unsigned int t_1_i) {
  int answers;
  empty(answers);
  empty(answers);
  int ret_0;
  if ((((t_0_right_most - t_0_i) >= 1) && ((t_1_right_most - t_1_i) >= 0))) {
    int ret_4 = nt_I((t_0_i + 1), t_1_i);
    int a_1 = ret_4;
    if (is_not_empty(a_1)) {
      char ret_2 = CHAR(t_0_seq, t_0_i, (t_0_i + 1));
      char ret_1_0 = ret_2;
      bool ret_3 = EMPTY(t_1_seq, t_1_i, t_1_i);
      bool ret_1_1 = ret_3;
      char a_0_0 = ret_1_0;
      bool a_0_1 = ret_1_1;
      if ((is_not_empty(a_0_0) && is_not_empty(a_0_1))) {
        ret_0 = Ins(a_0_0, a_0_1, a_1);
      } else {
        empty(ret_0);
      }
      erase(a_0_0);
      erase(a_0_1);
    } else {
      empty(ret_0);
    }
    erase(a_1);
  } else {
    empty(ret_0);
  }
  if (is_not_empty(ret_0)) {
    push_back_max(answers, ret_0);
  }
  int ret_5 = nt_R(t_0_i, t_1_i);
  if (is_not_empty(ret_5)) {
    push_back_max(answers, ret_5);
  }
  int eval = h(answers);
  erase(answers);
  return eval;
}

int out::nt_R(unsigned int t_0_i, unsigned int t_1_i) {
  int answers;
  empty(answers);
  empty(answers);
  int ret_0;
  if ((((t_0_right_most - t_0_i) >= 1) && ((t_1_right_most - t_1_i) >= 1))) {
    int ret_4 = nt_A((t_0_i + 1), (t_1_i + 1));
    int a_1 = ret_4;
    if (is_not_empty(a_1)) {
      char ret_2 = CHAR(t_0_seq, t_0_i, (t_0_i + 1));
      char ret_1_0 = ret_2;
      char ret_3 = CHAR(t_1_seq, t_1_i, (t_1_i + 1));
      char ret_1_1 = ret_3;
      char a_0_0 = ret_1_0;
      char a_0_1 = ret_1_1;
      if ((is_not_empty(a_0_0) && is_not_empty(a_0_1))) {
        ret_0 = Ers(a_0_0, a_0_1, a_1);
      } else {
        empty(ret_0);
      }
      erase(a_0_0);
      erase(a_0_1);
    } else {
      empty(ret_0);
    }
    erase(a_1);
  } else {
    empty(ret_0);
  }
  if (is_not_empty(ret_0)) {
    push_back_max(answers, ret_0);
  }
  int ret_5;
  if ((((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)) && ((t_1_right_most - t_1_i) >= 0)) && ((t_1_right_most - t_1_i) <= 0))) {
    bool ret_7 = EMPTY(t_0_seq, t_0_i, t_0_i);
    bool ret_6_0 = ret_7;
    bool ret_8 = EMPTY(t_1_seq, t_1_i, t_1_i);
    bool ret_6_1 = ret_8;
    bool a_2_0 = ret_6_0;
    bool a_2_1 = ret_6_1;
    if ((is_not_empty(a_2_0) && is_not_empty(a_2_1))) {
      ret_5 = Sto(a_2_0, a_2_1);
    } else {
      empty(ret_5);
    }
    erase(a_2_0);
    erase(a_2_1);
  } else {
    empty(ret_5);
  }
  if (is_not_empty(ret_5)) {
    push_back_max(answers, ret_5);
  }
  int eval = h(answers);
  erase(answers);
  return eval;
}


int out::Del(bool VOID_INTERNAL13, char b, int x) {
#line 120 "alignment.gap"
  return (x - 2);
#line 280 "out.cc"
}

int out::Ers(char a, char b, int x) {
#line 123 "alignment.gap"
  if ((a == b)) {
    return (x + 1);
  } else {
    return (x - 1);
  }
#line 290 "out.cc"
}

int out::Ins(char a, bool VOID_INTERNAL12, int x) {
#line 117 "alignment.gap"
  return (x - 2);
#line 296 "out.cc"
}

int out::Sto(bool VOID_INTERNAL14, bool VOID_INTERNAL15) {
#line 131 "alignment.gap"
  return 0;
#line 302 "out.cc"
}

int out::h(int candidates) {
  return candidates;
  return maximum(candidates);
}


void out::cyk() {
}

#ident "$Id: Compiled with gapc 2021.05.18 $"
