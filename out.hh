
// A dynamic programming evaluator generated by GAP-C.
//
//   GAP-C version:
//     2021.05.18
//
//   GAP-C call:
//     gapc -i global alignment.gap --tab A --tab D
//
//


#ifndef out_hh
#define out_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<char, unsigned> TUSubsequence;

struct typ_ali {
  Rope first;
  Rope second;
  bool empty_;
  typ_ali() : empty_(false) {}

};

inline std::ostream &operator<<(std::ostream &o, const typ_ali &tuple) {
  o << '('   << tuple.first   << ", " << tuple.second
   << ')' ;
  return o;
}

inline void empty(typ_ali &e) {e.empty_ = true; }
inline bool isEmpty(const typ_ali &e) { return e.empty_; }
#include "rtlib/subopt.hh"

#include "rtlib/generic_opts.hh"
#include "rtlib/pareto_dom_sort.hh"
#include "rtlib/pareto_yukish_ref.hh"

class out {
 public:
  Basic_Sequence<char> t_0_seq;
  Basic_Sequence<char> t_1_seq;
  unsigned int t_0_left_most;
  unsigned int t_0_right_most;
  unsigned int t_1_left_most;
  unsigned int t_1_right_most;

  int int_zero;

  class A_table_t {
   private:
    unsigned int t_0_left_most;
    unsigned int t_0_right_most;
    unsigned int t_1_left_most;
    unsigned int t_1_right_most;
    std::vector<int> array;
    std::vector<bool> tabulated;
    unsigned int t_0_n;
    unsigned int t_1_n;
    int zero;
    unsigned int size() {
      return ((1 * ((t_1_n + 1) * 1)) * ((t_0_n + 1) * 1));
    }

   public:
    A_table_t() {
      empty(zero);
    }

    void init(unsigned int t_0_n_, unsigned int t_1_n_, const std::string &tname) {
      t_0_n = t_0_n_;
      t_1_n = t_1_n_;
      t_0_left_most = 0;
      t_0_right_most = t_0_n;
      t_1_left_most = 0;
      t_1_right_most = t_1_n;
      unsigned int newsize = size();
      array.resize(newsize);
      tabulated.clear();
      tabulated.resize(newsize);
    }

    bool is_tabulated(unsigned int t_0_i, unsigned int t_1_i) {
      unsigned int t_1_j = t_1_n;
      assert((t_1_i <= t_1_j));
      assert((t_1_j <= t_1_n));
      if ((t_1_j < (t_1_n - 0))) {
        return true;
      }
      unsigned int t_1_real_j = (t_1_n - t_1_j);
      unsigned int t_0_j = t_0_n;
      assert((t_0_i <= t_0_j));
      assert((t_0_j <= t_0_n));
      if ((t_0_j < (t_0_n - 0))) {
        return true;
      }
      unsigned int t_0_real_j = (t_0_n - t_0_j);
      return tabulated[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
    }

    void clear() {
      tabulated.clear();
    }

    int &  get(unsigned int t_0_i, unsigned int t_1_i) {
      unsigned int t_1_j = t_1_n;
      assert((t_1_i <= t_1_j));
      assert((t_1_j <= t_1_n));
      if ((t_1_j < (t_1_n - 0))) {
        return zero;
      }
      unsigned int t_1_real_j = (t_1_n - t_1_j);
      unsigned int t_0_j = t_0_n;
      assert((t_0_i <= t_0_j));
      assert((t_0_j <= t_0_n));
      if ((t_0_j < (t_0_n - 0))) {
        return zero;
      }
      unsigned int t_0_real_j = (t_0_n - t_0_j);
      assert(tabulated[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
      assert((((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
      return array[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
    }

    void set(unsigned int t_0_i, unsigned int t_1_i, int e) {
      unsigned int t_1_j = t_1_n;
      assert((t_1_i <= t_1_j));
      assert((t_1_j <= t_1_n));
      if ((t_1_j < (t_1_n - 0))) {
        return;
      }
      unsigned int t_1_real_j = (t_1_n - t_1_j);
      unsigned int t_0_j = t_0_n;
      assert((t_0_i <= t_0_j));
      assert((t_0_j <= t_0_n));
      if ((t_0_j < (t_0_n - 0))) {
        return;
      }
      unsigned int t_0_real_j = (t_0_n - t_0_j);
      assert(!is_tabulated(t_0_i, t_1_i));
      assert((((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
      array[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
      tabulated[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
    }
  };
  A_table_t A_table;

  class D_table_t {
   private:
    unsigned int t_0_left_most;
    unsigned int t_0_right_most;
    unsigned int t_1_left_most;
    unsigned int t_1_right_most;
    std::vector<int> array;
    std::vector<bool> tabulated;
    unsigned int t_0_n;
    unsigned int t_1_n;
    int zero;
    unsigned int size() {
      return ((1 * ((t_1_n + 1) * 1)) * ((t_0_n + 1) * 1));
    }

   public:
    D_table_t() {
      empty(zero);
    }

    void init(unsigned int t_0_n_, unsigned int t_1_n_, const std::string &tname) {
      t_0_n = t_0_n_;
      t_1_n = t_1_n_;
      t_0_left_most = 0;
      t_0_right_most = t_0_n;
      t_1_left_most = 0;
      t_1_right_most = t_1_n;
      unsigned int newsize = size();
      array.resize(newsize);
      tabulated.clear();
      tabulated.resize(newsize);
    }

    bool is_tabulated(unsigned int t_0_i, unsigned int t_1_i) {
      unsigned int t_1_j = t_1_n;
      assert((t_1_i <= t_1_j));
      assert((t_1_j <= t_1_n));
      if ((t_1_j < (t_1_n - 0))) {
        return true;
      }
      unsigned int t_1_real_j = (t_1_n - t_1_j);
      unsigned int t_0_j = t_0_n;
      assert((t_0_i <= t_0_j));
      assert((t_0_j <= t_0_n));
      if ((t_0_j < (t_0_n - 0))) {
        return true;
      }
      unsigned int t_0_real_j = (t_0_n - t_0_j);
      return tabulated[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
    }

    void clear() {
      tabulated.clear();
    }

    int &  get(unsigned int t_0_i, unsigned int t_1_i) {
      unsigned int t_1_j = t_1_n;
      assert((t_1_i <= t_1_j));
      assert((t_1_j <= t_1_n));
      if ((t_1_j < (t_1_n - 0))) {
        return zero;
      }
      unsigned int t_1_real_j = (t_1_n - t_1_j);
      unsigned int t_0_j = t_0_n;
      assert((t_0_i <= t_0_j));
      assert((t_0_j <= t_0_n));
      if ((t_0_j < (t_0_n - 0))) {
        return zero;
      }
      unsigned int t_0_real_j = (t_0_n - t_0_j);
      assert(tabulated[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
      assert((((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
      return array[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
    }

    void set(unsigned int t_0_i, unsigned int t_1_i, int e) {
      unsigned int t_1_j = t_1_n;
      assert((t_1_i <= t_1_j));
      assert((t_1_j <= t_1_n));
      if ((t_1_j < (t_1_n - 0))) {
        return;
      }
      unsigned int t_1_real_j = (t_1_n - t_1_j);
      unsigned int t_0_j = t_0_n;
      assert((t_0_i <= t_0_j));
      assert((t_0_j <= t_0_n));
      if ((t_0_j < (t_0_n - 0))) {
        return;
      }
      unsigned int t_0_real_j = (t_0_n - t_0_j);
      assert(!is_tabulated(t_0_i, t_1_i));
      assert((((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
      array[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
      tabulated[((0 + (1 * (t_1_i + (t_1_real_j * (t_1_n + 1))))) + ((1 * ((t_1_n + 1) * 1)) * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
    }
  };
  D_table_t D_table;

  void init(const gapc::Opts &opts) {
    const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
    if (inp.size() != 2)
        throw gapc::OptException("Number of input sequences does not match.");

    t_0_seq.copy(inp[0].first, inp[0].second);
    t_1_seq.copy(inp[1].first, inp[1].second);
    A_table.init(t_0_seq.size(), t_1_seq.size(), "A_table");
    D_table.init(t_0_seq.size(), t_1_seq.size(), "D_table");
    empty(int_zero);

    t_0_left_most = 0;
    t_0_right_most = t_0_seq.size();
    t_1_left_most = 0;
    t_1_right_most = t_1_seq.size();
  }

 private:
  int &  nt_A(unsigned int t_0_i, unsigned int t_1_i);

  int &  nt_D(unsigned int t_0_i, unsigned int t_1_i);

  int nt_Foo();

  int nt_I(unsigned int t_0_i, unsigned int t_1_i);

  int nt_R(unsigned int t_0_i, unsigned int t_1_i);


  int Del(bool VOID_INTERNAL13, char b, int x);

  int Ers(char a, char b, int x);

  int Ins(char a, bool VOID_INTERNAL12, int x);

  int Sto(bool VOID_INTERNAL14, bool VOID_INTERNAL15);

  int h(int candidates);


 public:
  void cyk();

 public:
  int run() {
    return nt_Foo();
  }

  void print_stats(std::ostream &o) {
#ifdef STATS
    o << "\n\nN = " << seq.size() << '\n';
    A_table.print_stats(o, "A_table");
    D_table.print_stats(o, "D_table");
#endif
  }

  template <typename Value> void  print_result(std::ostream &out, Value& res) {
    if (isEmpty(res)) {
      out << "[]\n";
    } else {
      out << res << '\n';
    }
  }

  template <typename Value> void print_backtrack(std::ostream &out, Value& value) {
  }

  void print_subopt(std::ostream &out, int  delta = 0) {
  }
};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef out class_name;
  typedef int return_type;
}
#endif

#endif
